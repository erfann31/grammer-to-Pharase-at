# grammer to Pharase-at
 To convert right linear grammar to a regular expression

ورودی ها در یک مپ با کلید های استرینگ و ولیو های اری لیستی از استرینگ ها ذخیره میشود به طوری که کلید ها همان سمت چپ # یا وریبل ها هستند و اعضای ولیو ها همان قوانین مربوط به هر ولیو میباشد برای مثال داریم:
S#aB
S#bB

key="S" , value:{[aB],[bB]}
 
ما در این پروژه استیت شروع را S و استیت پایان را استیتی که قانون آن دارای علامت $ باشد فرض میکنیم.
لاندا در این برنامه مثل بقیه حروف میتواند به برنامه داده شود مثلا:
S#lambdaB
B#$
پس از دریافت ورودی ها در خط 35 استیت های ترپ به این صورت که اگر آخرین کارکتر قانون آنها شامل حرفی بود که در مجموعه کلید ها وجود نداشت شناسایی و حذف میشوند.
سپس از خط 36 تا 50 برنامه بررسی میکند که اگر اخرین کارکتر از 2 شرط یا قانون برای یک وریبل مثل هم بود از علامت اجتماع(U) بین آنها استفاده کند.
سپس از خط 51 تا 68 برنامه بررسی میکند که آیا در قوانین یک وریبل قانونی وجود دارد که آنرا به استیت های قبلی برگرداند یا خیر و اگر بود ترکیب آنها را جایگزین میکند. روش کار به این صورت است که اری لیستی تمام وریبل های قبلی را نگه داری میکند یعنی با پیمایش روی کلید های ترتیب دار ابتدا کلید به اری لیست اضافه میشود سپس روی همه ی قوانین وریبل جاری پیمایش انجام میشود و اگر آخرین کارکتر قانون بررسی شده در لیست وریبل های قبلی وجود داشت(بجز وریبل جاری) آنرا با قانون قبلی ترکیب کرده و به لیست قانون های وریبل پیمایش شده اضافه میکند و آن 2 قانون ترکیب شده را از لیست قانون ها حذف میکند؛ همچنین بررسی میکند اگر تعداد قوانین یکی شد یک قانون با اخرین کارکتر قبلی بعد از قانون ترکیب شده اضافه میکند.(بهتر این نمیتونستم بگم مثال بزن میفهمی چقدر الگوریتم خوبیه:)*)
توضیح تابع mapToPharase:
تابع تابعی بازگشتی است که با گرفتن مپ ورودی و استیت شروع عبارت منظم را خروجی میدهد و شرط خاتمه این است که لیست قوانین دارای قانونی با علامت "$" باشد.
طریق کار تابع بع این صورت است که بررسی میکند که آیا قوانین استیت ورودی شامل استیت ورودی هست یا خیر اگر بود علامت "*" را قرار میدهد، قانون را حذف کرده و تابع را با اخرین کارکتر که همان استیت ورودی است باز فراخوانی میکند؛ ولی اگر شامل استیت ورودی نبود قانون جاری را به استرینگ بیلدر اضافه میکند و باز تابع را با اخرین کارکتر فراخوانی میکند. همچنین اگر در یک وریبل 2 راه وجود داشت بین 2 راه علامت اجتماع میگذارد (باز بد گفتم ولی فکر کنم فهمیدی چی شد:)*)
در آخر همه ی کلید ها را از استرینگ بیلدر حذف میکند و خروجی را برمیگرداند.
